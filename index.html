<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue.js & Web Audio API MIDI Keyboard</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Vue.js 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Tonal.js (Music Theory Library) -->
    <script src="https://cdn.jsdelivr.net/npm/tonal/browser/tonal.min.js"></script>
    <style>
      /* UI and animation styles */
      body {
        font-family: 'Inter', sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      .keyboard-wrapper {
        position: relative;
        width: 100%;
        border: 2px solid #334155;
        border-radius: 8px;
        background-color: #1e293b;
        padding: 1rem;
        box-shadow:
          0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }
      .keyboard-container {
        position: relative;
        width: 100%;
      }
      .key {
        cursor: pointer;
        transition: all 0.07s ease;
        position: absolute; /* All keys are absolutely positioned */
        display: flex;
        align-items: flex-end;
        justify-content: center;
        padding-bottom: 8px;
        font-weight: 500;
        user-select: none;
        box-sizing: border-box;
      }
      .key.white {
        background-color: #f8fafc;
        border: 1px solid #94a3b8;
        border-radius: 0 0 5px 5px;
        color: #475569;
        z-index: 1;
      }
      .key.white.pressed {
        background-color: #67e8f9;
        transform: translateY(2px);
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
      }
      .key.black {
        background: linear-gradient(45deg, #262626, #404040);
        border: 1px solid #171717;
        border-radius: 0 0 4px 4px;
        color: #e2e8f0;
        z-index: 2;
        box-shadow:
          -1px -1px 2px rgba(255, 255, 255, 0.2) inset,
          0 -5px 2px 3px rgba(0, 0, 0, 0.6) inset,
          0 2px 4px rgba(0, 0, 0, 0.5);
      }
      .key.black.pressed {
        background: #67e8f9;
        box-shadow:
          -1px -1px 2px rgba(255, 255, 255, 0.2) inset,
          0 -2px 2px 3px rgba(0, 0, 0, 0.6) inset,
          0 1px 2px rgba(0, 0, 0, 0.5);
        transform: translateY(1px);
      }
      .note-name {
        font-size: 0.8rem;
      }
      .chord-display {
        font-size: 3rem;
        font-weight: 700;
        text-shadow: 0 0 15px rgba(125, 211, 252, 0.5);
      }
      .target-chord-display {
        font-size: 5rem;
        font-weight: 800;
        color: #f0f9ff;
      }
    </style>
  </head>
  <body class="bg-slate-900 text-slate-200 flex items-center justify-center min-h-screen p-4">
    <div id="app" class="w-full max-w-7xl mx-auto text-center">
      <div class="mb-8">
        <h1 class="text-4xl font-bold text-sky-400">Vue & Web Audio API MIDI Keyboard</h1>
        <p class="text-slate-400 mt-2">
          Connect your MIDI keyboard, set the number of keys, and start playing.
        </p>
      </div>

      <!-- Setup Panel -->
      <div v-if="!isInitialized" class="mb-6 space-y-4">
        <div class="flex items-center justify-center gap-4">
          <label for="midiDevice" class="font-medium">MIDI Device:</label>
          <select
            v-model="selectedMidiInputId"
            @change="onDeviceSelected"
            id="midiDevice"
            class="p-2 rounded-md bg-slate-700 text-white border border-slate-600 focus:ring-2 focus:ring-sky-500 focus:outline-none"
          >
            <option :value="null" disabled>-- Select a device --</option>
            <option v-for="input in midiInputs" :key="input.id" :value="input.id">
              {{ input.name }}
            </option>
          </select>
        </div>

        <!-- Calibration Step -->
        <div
          v-if="selectedMidiInputId"
          class="mt-4 p-3 rounded-md transition-colors duration-300"
          :class="isCalibrated ? 'bg-green-900 text-green-200' : 'bg-sky-900 text-sky-200'"
        >
          <p>{{ calibrationMessage }}</p>
        </div>

        <div class="flex items-center justify-center gap-4 mt-4">
          <label for="keyCount" class="font-medium">Number of Keys:</label>
          <input
            type="number"
            v-model.number="numberOfKeys"
            min="25"
            max="88"
            id="keyCount"
            class="w-24 p-2 rounded-md bg-slate-700 text-white border border-slate-600 focus:ring-2 focus:ring-sky-500 focus:outline-none"
          />
        </div>
        <div class="mt-4">
          <button
            @click="start"
            :disabled="!selectedMidiInputId || !isCalibrated"
            class="px-6 py-2 bg-sky-600 hover:bg-sky-700 rounded-md font-semibold transition-colors shadow-lg disabled:bg-slate-600 disabled:cursor-not-allowed"
          >
            Start
          </button>
        </div>
      </div>

      <!-- Training Area -->
      <div
        v-if="isInitialized"
        class="p-4 border-2 border-slate-700 rounded-lg mb-8 bg-slate-800/50"
      >
        <h2 class="text-2xl font-bold text-sky-400 mb-4">Chord Training</h2>
        <div class="flex flex-wrap items-center justify-center gap-x-6 gap-y-4 mb-4">
          <div class="flex items-center gap-2">
            <input
              type="checkbox"
              v-model="chordTypeSelection.M"
              id="major"
              class="h-4 w-4 rounded"
              :disabled="isGameRunning"
            />
            <label for="major" :class="{'opacity-50': isGameRunning}">Major</label>
          </div>
          <div class="flex items-center gap-2">
            <input
              type="checkbox"
              v-model="chordTypeSelection.m"
              id="minor"
              class="h-4 w-4 rounded"
              :disabled="isGameRunning"
            />
            <label for="minor" :class="{'opacity-50': isGameRunning}">Minor</label>
          </div>
          <div class="flex items-center gap-2">
            <input
              type="checkbox"
              v-model="chordTypeSelection.maj7"
              id="maj7"
              class="h-4 w-4 rounded"
              :disabled="isGameRunning"
            />
            <label for="maj7" :class="{'opacity-50': isGameRunning}">Major 7</label>
          </div>
          <div class="flex items-center gap-2">
            <input
              type="checkbox"
              v-model="chordTypeSelection.m7"
              id="min7"
              class="h-4 w-4 rounded"
              :disabled="isGameRunning"
            />
            <label for="min7" :class="{'opacity-50': isGameRunning}">Minor 7</label>
          </div>
        </div>
        <div class="flex items-center justify-center gap-x-6 gap-y-2 mb-4">
            <span class="font-medium text-slate-300" :class="{'opacity-50': isGameRunning}">Notation:</span>
            <label class="flex items-center gap-2" :class="isGameRunning ? 'cursor-not-allowed opacity-50' : 'cursor-pointer'">
                <input type="radio" v-model="notationPreference" value="flats" name="notation" class="h-4 w-4 text-sky-600 bg-slate-700 border-slate-500 focus:ring-sky-500" :disabled="isGameRunning">
                <span>Flats (b)</span>
            </label>
            <label class="flex items-center gap-2" :class="isGameRunning ? 'cursor-not-allowed opacity-50' : 'cursor-pointer'">
                <input type="radio" v-model="notationPreference" value="sharps" name="notation" class="h-4 w-4 text-sky-600 bg-slate-700 border-slate-500 focus:ring-sky-500" :disabled="isGameRunning">
                <span>Sharps (#)</span>
            </label>
        </div>
        <div class="flex items-center justify-center gap-4">
          <label for="timerDuration">Duration (sec):</label>
          <select
            v-model.number="gameDuration"
            id="timerDuration"
            :disabled="isGameRunning"
            class="p-2 rounded-md bg-slate-700 text-white"
          >
            <option v-for="n in 10" :value="n">{{ n }}</option>
          </select>
          <button
            @click="toggleGame"
            class="px-6 py-2 rounded-md font-semibold transition-colors"
            :class="isGameRunning ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'"
          >
            {{ isGameRunning ? 'Stop' : 'Start Training' }}
          </button>
        </div>
        <div v-if="isGameRunning" class="mt-4">
          <p class="text-lg">Target Chord:</p>
          <p class="target-chord-display">{{ targetChord }}</p>
          <p class="text-2xl font-mono">{{ gameCountdown }}</p>
        </div>
      </div>

      <div class="mb-4">
        <p class="text-lg">
          MIDI Status:
          <span :class="midiStatus.connected ? 'text-green-400' : 'text-yellow-400'"
            >{{ midiStatus.message }}</span
          >
        </p>
      </div>

      <div class="mb-8 flex items-center justify-center h-24">
        <p class="chord-display transition-colors duration-300" :class="userChordColorClass">
          {{ detectedChord }}
        </p>
      </div>

      <div class="w-full pb-4">
        <div class="keyboard-wrapper" ref="keyboardWrapper">
          <div
            v-if="keyboardKeys.length > 0"
            class="keyboard-container"
            :style="{ height: keyboardHeight + 'px' }"
          >
            <div
              v-for="key in keyboardKeys"
              :key="key.midi"
              :class="['key', key.type, { 'pressed': key.isPressed }]"
              :style="key.styleObject"
              @mousedown="playNoteFromClick(key.midi, 100)"
              @mouseup="stopNoteFromClick(key.midi)"
              @mouseleave="stopNoteFromClick(key.midi)"
            >
              <span class="note-name" v-if="key.type === 'white'"
                >{{ Tonal.Midi.midiToNoteName(key.midi, { pitchClass: true, sharps: notationPreference === 'sharps' }) }}</span
              >
            </div>
          </div>
        </div>
        <div v-if="!isInitialized" class="text-slate-500 mt-4">
          Select a MIDI device and click 'Start' to build the keyboard.
        </div>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const { createApp } = Vue

        createApp({
          data() {
            return {
              numberOfKeys: 49,
              startMidiNote: null,
              keyboardKeys: [],
              keyboardHeight: 0,
              pressedMidiNotes: new Map(),
              audioContext: null,
              midiAccess: null,
              detectedChord: '',
              midiStatus: { connected: false, message: 'Not Ready' },
              Tonal: Tonal,
              isInitialized: false,
              isCalibrated: false,
              calibrationMessage: 'Please select a MIDI device to calibrate.',
              midiInputs: [],
              selectedMidiInputId: null,
              resizeTimeout: null,
              isGameRunning: false,
              gameTimerId: null,
              gameDuration: 5,
              gameCountdown: 5,
              targetChord: '',
              chordTypeSelection: { M: true, m: true, maj7: false, m7: false },
              userChordStatus: 'neutral', // 'neutral', 'correct', 'incorrect'
              notationPreference: 'flats', // 'flats' or 'sharps'
              rootNotesSharps: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
              rootNotesFlats: ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'],
            }
          },
          computed: {
            userChordColorClass() {
              switch (this.userChordStatus) {
                case 'correct':
                  return 'text-green-400'
                case 'incorrect':
                  return 'text-red-400'
                default:
                  return 'text-sky-300'
              }
            },
            useSharps() {
                return this.notationPreference === 'sharps';
            }
          },
          methods: {
            async start() {
              const audioReady = await this.initAudio()
              if (!audioReady) {
                console.error('Audio engine failed to initialize, aborting start.')
                return
              }
              this.isInitialized = true
              this.$nextTick(() => {
                this.generateKeyboard()
                this.connectToSelectedDevice()
              })
            },
            initAudio() {
              return new Promise(async (resolve) => {
                try {
                  if (this.audioContext && this.audioContext.state === 'running') {
                    resolve(true)
                    return
                  }
                  this.audioContext = new (window.AudioContext || window.webkitAudioContext)()
                  if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume()
                  }
                  console.log(
                    'Web Audio API engine started successfully. Status:',
                    this.audioContext.state,
                  )
                  resolve(true)
                } catch (e) {
                  console.error('Error in initAudio:', e)
                  this.midiStatus.message = `Error: Could not initialize audio engine. (${e.name})`
                  this.isInitialized = false
                  resolve(false)
                }
              })
            },
            async initMidi() {
              if (!navigator.requestMIDIAccess) {
                this.midiStatus = {
                  connected: false,
                  message: 'Your browser does not support the Web MIDI API.',
                }
                return
              }
              try {
                this.midiAccess = await navigator.requestMIDIAccess()
                this.midiInputs = Array.from(this.midiAccess.inputs.values())
                if (this.midiInputs.length > 0) {
                  this.midiStatus = { connected: false, message: 'Please select a MIDI device.' }
                } else {
                  this.midiStatus = { connected: false, message: 'No MIDI device found.' }
                }
                this.midiAccess.onstatechange = (event) => {
                  this.midiInputs = Array.from(this.midiAccess.inputs.values())
                  if (
                    this.selectedMidiInputId &&
                    !this.midiInputs.find((i) => i.id === this.selectedMidiInputId)
                  ) {
                    this.midiStatus.connected = false
                    this.midiStatus.message = 'The connected MIDI device was removed.'
                    this.isInitialized = false
                    this.isCalibrated = false
                    this.selectedMidiInputId = null
                    this.calibrationMessage = 'Please select a MIDI device to calibrate.'
                    this.stopGame()
                  }
                }
              } catch (error) {
                console.error('MIDI access error:', error)
                this.midiStatus = { connected: false, message: 'MIDI access was denied.' }
              }
            },
            onDeviceSelected() {
              if (!this.selectedMidiInputId || !this.midiAccess) return
              this.isCalibrated = false
              this.calibrationMessage =
                'Please press the LOWEST (left-most) key on your keyboard...'
              this.midiAccess.inputs.forEach((input) => {
                input.onmidimessage = null
              })
              const selectedInput = this.midiAccess.inputs.get(this.selectedMidiInputId)
              if (selectedInput) {
                selectedInput.onmidimessage = (event) => {
                  const [command, midiNote, velocity] = event.data
                  if (command === 144 && velocity > 0) {
                    this.startMidiNote = midiNote
                    this.isCalibrated = true
                    const noteName = this.Tonal.Midi.midiToNoteName(this.startMidiNote, { sharps: this.useSharps })
                    this.calibrationMessage = `Calibration complete! Starting note: ${noteName} (${this.startMidiNote})`
                    selectedInput.onmidimessage = null
                  }
                }
              }
            },
            connectToSelectedDevice() {
              if (!this.selectedMidiInputId || !this.midiAccess) return
              this.midiAccess.inputs.forEach((input) => {
                input.onmidimessage = null
              })
              const selectedInput = this.midiAccess.inputs.get(this.selectedMidiInputId)
              if (selectedInput) {
                selectedInput.onmidimessage = this.onMIDIMessage
                this.midiStatus = { connected: true, message: `Connected: ${selectedInput.name}` }
              }
            },
            onMIDIMessage(event) {
              const [command, midiNote, velocity] = event.data
              if (command === 144 && velocity > 0) {
                this.pressKey(midiNote, velocity)
              } else if (command === 128 || (command === 144 && velocity === 0)) {
                this.releaseKey(midiNote)
              }
            },
            generateKeyboard() {
              if (!this.$refs.keyboardWrapper) return
              const keys = []
              let whiteKeyCount = 0
              for (let i = 0; i < this.numberOfKeys; i++) {
                const midi = this.startMidiNote + i
                const noteName = this.Tonal.Midi.midiToNoteName(midi, { sharps: this.useSharps })
                if (!noteName.includes('#') && !noteName.includes('b')) {
                  whiteKeyCount++
                }
              }
              const containerWidth = this.$refs.keyboardWrapper.clientWidth - 32
              const whiteKeyWidth = containerWidth / whiteKeyCount
              const whiteKeyHeight = whiteKeyWidth * 4
              const blackKeyWidth = whiteKeyWidth * 0.6
              const blackKeyHeight = whiteKeyHeight * 0.6
              this.keyboardHeight = whiteKeyHeight
              let whiteKeyIndex = 0
              for (let i = 0; i < this.numberOfKeys; i++) {
                const midi = this.startMidiNote + i
                const noteName = this.Tonal.Midi.midiToNoteName(midi, { sharps: this.useSharps })
                const isBlack = noteName.includes('#') || noteName.includes('b')
                const keyData = {
                  midi,
                  note: noteName,
                  type: isBlack ? 'black' : 'white',
                  isPressed: false,
                  styleObject: {},
                }
                if (isBlack) {
                  keyData.styleObject = {
                    width: `${blackKeyWidth}px`,
                    height: `${blackKeyHeight}px`,
                    left: `${whiteKeyIndex * whiteKeyWidth - blackKeyWidth / 2}px`,
                  }
                } else {
                  keyData.styleObject = {
                    width: `${whiteKeyWidth}px`,
                    height: `${whiteKeyHeight}px`,
                    left: `${whiteKeyIndex * whiteKeyWidth}px`,
                  }
                  whiteKeyIndex++
                }
                keys.push(keyData)
              }
              this.keyboardKeys = keys
            },
            pressKey(midiNote, velocity = 100) {
              if (!this.audioContext || this.audioContext.state !== 'running') return
              if (this.pressedMidiNotes.has(midiNote)) this.releaseKey(midiNote, true)
              const oscillator = this.audioContext.createOscillator()
              const gainNode = this.audioContext.createGain()
              oscillator.connect(gainNode)
              gainNode.connect(this.audioContext.destination)
              oscillator.type = 'sine'
              oscillator.frequency.value = this.Tonal.Midi.midiToFreq(midiNote)
              const normalizedVelocity = velocity / 127
              gainNode.gain.setValueAtTime(normalizedVelocity, this.audioContext.currentTime)
              oscillator.start()
              this.pressedMidiNotes.set(midiNote, { oscillator, gainNode })
              const key = this.keyboardKeys.find((k) => k.midi === midiNote)
              if (key) key.isPressed = true
              this.detectChord()
            },
            releaseKey(midiNote, isRetrigger = false) {
              if (this.pressedMidiNotes.has(midiNote)) {
                const { oscillator, gainNode } = this.pressedMidiNotes.get(midiNote)
                const releaseTime = 0.5
                gainNode.gain.setValueAtTime(gainNode.gain.value, this.audioContext.currentTime)
                gainNode.gain.linearRampToValueAtTime(
                  0,
                  this.audioContext.currentTime + releaseTime,
                )
                oscillator.stop(this.audioContext.currentTime + releaseTime)
                this.pressedMidiNotes.delete(midiNote)
              }
              if (isRetrigger) return
              const key = this.keyboardKeys.find((k) => k.midi === midiNote)
              if (key) key.isPressed = false
              this.detectChord()
            },
            detectChord() {
              const midiNotes = Array.from(this.pressedMidiNotes.keys());
              
              if (midiNotes.length >= 3) {
                  midiNotes.sort((a, b) => a - b);
                  const notes = midiNotes.map((midi) =>
                      this.Tonal.Midi.midiToNoteName(midi, { pitchClass: true, sharps: this.useSharps })
                  );
                  const chords = this.Tonal.Chord.detect(notes);
                  this.detectedChord = chords.length > 0 ? chords[0] : '';
              } else {
                  this.detectedChord = '';
              }

              if (this.isGameRunning) {
                  const targetChordInfo = this.Tonal.Chord.get(this.targetChord);

    
                  if (targetChordInfo.empty) {
                      this.userChordStatus = 'neutral';
                      return;
                  }
                  
                  if (midiNotes.length !== targetChordInfo.notes.length) {
                      this.userChordStatus = midiNotes.length > 0 ? 'incorrect' : 'neutral';
                      return;
                  }

                  const playedChromaSet = new Set(midiNotes.map(midi => midi % 12));
                  const targetChromaSet = new Set(targetChordInfo.notes.map(note => this.Tonal.Note.chroma(note)));
                  const isEqual = [...playedChromaSet].every(value => targetChromaSet.has(value));

                  this.userChordStatus = isEqual ? 'correct' : 'incorrect';
              } else {
                  this.userChordStatus = 'neutral';
              }
            },
            handleResize() {
              clearTimeout(this.resizeTimeout)
              this.resizeTimeout = setTimeout(() => {
                if (this.isInitialized) this.generateKeyboard()
              }, 150)
            },
            async playNoteFromClick(midiNote, velocity) {
              if (!this.audioContext || this.audioContext.state !== 'running') {
                const audioReady = await this.initAudio()
                if (audioReady) this.pressKey(midiNote, velocity)
              } else {
                this.pressKey(midiNote, velocity)
              }
            },
            stopNoteFromClick(midiNote) {
              if (this.pressedMidiNotes.has(midiNote)) this.releaseKey(midiNote)
            },
            // --- Training Methods ---
            toggleGame() {
              this.isGameRunning ? this.stopGame() : this.startGame()
            },
            startGame() {
              const availableTypes = Object.keys(this.chordTypeSelection).filter(
                (type) => this.chordTypeSelection[type],
              )
              if (availableTypes.length === 0) {
                alert('Please select at least one chord type.')
                return
              }
              this.isGameRunning = true
              this.gameCountdown = this.gameDuration
              this.nextChord()
              this.gameTimerId = setInterval(this.gameLoop, 1000)
            },
            stopGame() {
              this.isGameRunning = false
              clearInterval(this.gameTimerId)
              this.targetChord = ''
              this.userChordStatus = 'neutral'
            },
            gameLoop() {
              this.gameCountdown--
              if (this.gameCountdown <= 0) {
                this.nextChord()
                this.gameCountdown = this.gameDuration
              }
            },
            nextChord() {
                const availableTypes = Object.keys(this.chordTypeSelection).filter(
                    (type) => this.chordTypeSelection[type]
                );
                const rootNotes = this.useSharps ? this.rootNotesSharps : this.rootNotesFlats;
                const totalOptions = availableTypes.length * rootNotes.length;

                if (totalOptions <= 1) {
                    const randomRoot = rootNotes[Math.floor(Math.random() * rootNotes.length)];
                    const randomType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                    this.targetChord = randomRoot + randomType;
                } else {
                    let newChord = '';
                    do {
                        const randomRoot = rootNotes[Math.floor(Math.random() * rootNotes.length)];
                        const randomType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                        newChord = randomRoot + randomType;
                    } while (newChord === this.targetChord);
                    this.targetChord = newChord;
                }

                this.userChordStatus = 'neutral';
                this.detectChord();
            },
          },
          watch: {
            notationPreference() {
                if (this.isInitialized) {
                    this.generateKeyboard();
                }
            }
          },
          mounted() {
            this.initMidi()
            window.addEventListener('resize', this.handleResize)
          },
          beforeUnmount() {
            window.removeEventListener('resize', this.handleResize)
            this.stopGame()
          },
        }).mount('#app')
      })
    </script>
  </body>
</html>


